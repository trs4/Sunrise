using Sunrise.Model.SoundFlow.Abstracts;
using Sunrise.Model.SoundFlow.Midi.Devices;
using Sunrise.Model.SoundFlow.Midi.Enums;
using Sunrise.Model.SoundFlow.Midi.Interfaces;
using Sunrise.Model.SoundFlow.Midi.Routing.Nodes;
using Sunrise.Model.SoundFlow.Midi.Structs;
using Sunrise.Model.SoundFlow.Structs;
using Sunrise.Model.SoundFlow.Synthesis;

namespace Sunrise.Model.SoundFlow.Midi.Routing;

/// <summary>
/// A centralized hub for managing all MIDI I/O, device management, and routing within the audio engine.
/// It functions as a virtual patch bay for connecting MIDI sources to destinations.
/// </summary>
public sealed class MidiManager : IDisposable
{
    /// <summary>
    /// Defines an MPE (MIDI Polyphonic Expression) zone for an input device.
    /// </summary>
    /// <param name="MasterChannel">The master channel (typically 1 or 16) used for global messages.</param>
    /// <param name="MemberChannelsStart">The first channel in the block used for per-note messages.</param>
    /// <param name="MemberChannelCount">The number of channels in the member block.</param>
    public record MpeZone(int MasterChannel, int MemberChannelsStart, int MemberChannelCount);

    /// <summary>
    /// Internal event structure for a global pitch bend message, generated by the MpeParser.
    /// </summary>
    internal record GlobalPitchBendEvent(int PitchBendValue);

    /// <summary>
    /// Internal event structure for a per-note pitch bend message, generated by the MpeParser.
    /// </summary>
    internal record PerNotePitchBendEvent(int Channel, int NoteNumber, float BendSemitones);

    /// <summary>
    /// Internal event structure for a per-note pressure message, generated by the MpeParser.
    /// </summary>
    internal record PerNotePressureEvent(int Channel, int NoteNumber, float Pressure);

    /// <summary>
    /// Internal event structure for a per-note timbre message, generated by the MpeParser.
    /// </summary>
    internal record PerNoteTimbreEvent(int Channel, int NoteNumber, float Timbre);
    
    private readonly AudioEngine _engine;
    private readonly object _lock = new();

    private readonly List<MidiInputDevice> _activeInputDevices = [];
    private readonly List<MidiOutputDevice> _activeOutputDevices = [];
    
    // Routing State (Managed with Copy-On-Write)
    private readonly List<MidiRoute> _routesStaging = [];
    private volatile MidiRoute[] _routesSnapshot = [];
    
    // Nodes serve as wrappers for physical devices and internal targets
    private readonly Dictionary<MidiDeviceInfo, MidiInputNode> _inputNodesStaging = new();
    private volatile Dictionary<MidiDeviceInfo, MidiInputNode> _inputNodesSnapshot = new();
    
    private readonly Dictionary<MidiDeviceInfo, MidiOutputNode> _outputNodes = new(); // Output nodes only accessed via routing setup
    
    // MPE-specific state
    private readonly Dictionary<MidiDeviceInfo, MpeZone> _mpeZones = new();
    private readonly Dictionary<MidiDeviceInfo, MpeParser> _mpeParsersStaging = new();
    private volatile Dictionary<MidiDeviceInfo, MpeParser> _mpeParsersSnapshot = new();

    /// <summary>
    /// Occurs when a MIDI route encounters a non-recoverable error, such as a device failure.
    /// </summary>
    public event Action<MidiRoute, IError?>? OnRouteFaulted;

    /// <summary>
    /// Gets a read-only list of all available MIDI input devices.
    /// </summary>
    public IReadOnlyList<MidiDeviceInfo> AvailableInputs => _engine.MidiInputDevices;

    /// <summary>
    /// Gets a read-only list of all available MIDI output devices.
    /// </summary>
    public IReadOnlyList<MidiDeviceInfo> AvailableOutputs => _engine.MidiOutputDevices;

    /// <summary>
    /// Gets a read-only list of all active MIDI routing connections.
    /// </summary>
    public IReadOnlyList<MidiRoute> Routes
    {
        get
        {
            lock (_lock)
            {
                return _routesStaging.ToList().AsReadOnly();
            }
        }
    }
    
    /// <summary>
    /// Gets a read-only list of all routes that are in a faulted state due to an error.
    /// </summary>
    public IReadOnlyList<MidiRoute> FaultedRoutes
    {
        get
        {
            lock (_lock)
            {
                return _routesStaging.Where(r => r.IsFaulted).ToList().AsReadOnly();
            }
        }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MidiManager"/> class.
    /// </summary>
    /// <param name="engine">The parent audio engine.</param>
    internal MidiManager(AudioEngine engine)
    {
        _engine = engine;
    }

    /// <summary>
    /// Configures a MIDI input device to operate as an MPE (MIDI Polyphonic Expression) source.
    /// Once configured, messages from this device's member channels will be interpreted as per-note expression data.
    /// </summary>
    /// <param name="deviceInfo">The MIDI input device to configure.</param>
    /// <param name="zone">The MPE zone configuration, specifying master and member channels.</param>
    public void ConfigureMpeZone(MidiDeviceInfo deviceInfo, MpeZone zone)
    {
        lock (_lock)
        {
            _mpeZones[deviceInfo] = zone;
            _mpeParsersStaging[deviceInfo] = new MpeParser(zone);
            _mpeParsersSnapshot = new Dictionary<MidiDeviceInfo, MpeParser>(_mpeParsersStaging);
        }
    }
    
    /// <summary>
    /// Removes the MPE configuration from a MIDI input device, causing it to revert to standard MIDI behavior.
    /// </summary>
    /// <param name="deviceInfo">The MIDI input device to deconfigure.</param>
    public void DeconfigureMpeZone(MidiDeviceInfo deviceInfo)
    {
        lock (_lock)
        {
            _mpeZones.Remove(deviceInfo);
            if (_mpeParsersStaging.Remove(deviceInfo))
            {
                _mpeParsersSnapshot = new Dictionary<MidiDeviceInfo, MpeParser>(_mpeParsersStaging);
            }
        }
    }

    /// <summary>
    /// Creates a direct route from a physical MIDI input device to an internal MIDI-controllable target (e.g., a Synthesizer).
    /// </summary>
    /// <param name="inputDevice">The source MIDI input device.</param>
    /// <param name="target">The target component that implements <see cref="IMidiControllable"/>.</param>
    /// <returns>The newly created <see cref="MidiRoute"/>.</returns>
    public MidiRoute CreateRoute(MidiDeviceInfo inputDevice, IMidiControllable target)
    {
        var inputNode = GetOrCreateInputNode(inputDevice);
        var targetNode = new MidiTargetNode(target); // Targets are lightweight and don't need caching
        var route = new MidiRoute(inputNode, targetNode);
        AddRoute(route);
        return route;
    }

    /// <summary>
    /// Creates a direct route from a physical MIDI input device to a physical MIDI output device (MIDI Thru).
    /// </summary>
    /// <param name="inputDevice">The source MIDI input device.</param>
    /// <param name="outputDevice">The destination MIDI output device.</param>
    /// <returns>The newly created <see cref="MidiRoute"/>.</returns>
    public MidiRoute CreateRoute(MidiDeviceInfo inputDevice, MidiDeviceInfo outputDevice)
    {
        var inputNode = GetOrCreateInputNode(inputDevice);
        var outputNode = GetOrCreateOutputNode(outputDevice);
        var route = new MidiRoute(inputNode, outputNode);
        AddRoute(route);
        return route;
    }

    /// <summary>
    /// Adds a pre-configured MIDI route to the manager.
    /// </summary>
    /// <param name="route">The route to add.</param>
    public void AddRoute(MidiRoute route)
    {
        lock (_lock)
        {
            if (!_routesStaging.Contains(route))
            {
                _routesStaging.Add(route);
                _routesSnapshot = _routesStaging.ToArray();
                route.OnError += HandleRouteFault;
                route.Start();
            }
        }
    }

    /// <summary>
    /// Removes a MIDI route from the manager.
    /// </summary>
    /// <param name="route">The route to remove.</param>
    /// <returns>True if the route was found and removed; otherwise, false.</returns>
    public bool RemoveRoute(MidiRoute route)
    {
        lock (_lock)
        {
            if (_routesStaging.Remove(route))
            {
                _routesSnapshot = _routesStaging.ToArray();
                route.OnError -= HandleRouteFault;
                route.Stop();
                return true;
            }
            return false;
        }
    }
    
    private void HandleRouteFault(MidiRoute route, IError? ex)
    {
        OnRouteFaulted?.Invoke(route, ex);
    }
    
    /// <summary>
    /// Gets an existing, or creates a new, managed MIDI input node for the specified device.
    /// This method is the recommended way to get an initialized, active MidiInputDevice instance
    /// without needing to create a full route.
    /// </summary>
    /// <param name="deviceInfo">The device information for the MIDI input device.</param>
    /// <returns>The corresponding <see cref="MidiInputNode"/>, which contains the active device instance.</returns>
    public MidiInputNode GetOrCreateInputNode(MidiDeviceInfo deviceInfo)
    {
        lock (_lock)
        {
            if (_inputNodesStaging.TryGetValue(deviceInfo, out var existingNode))
                return existingNode;
            
            var device = _engine.CreateMidiInputDevice(deviceInfo);
            var node = new MidiInputNode(device);
            
            _activeInputDevices.Add(device);
            
            _inputNodesStaging[deviceInfo] = node;
            _inputNodesSnapshot = new Dictionary<MidiDeviceInfo, MidiInputNode>(_inputNodesStaging);
            
            // Centralized subscriptions
            device.OnMessageReceived += OnDeviceMessageReceived;
            device.OnSysExReceived += OnDeviceSysExReceived;
            
            return node;
        }
    }

    /// <summary>
    /// Gets an existing, or creates a new, managed MIDI output node for the specified device.
    /// This method is the recommended way to get an initialized, active MidiOutputDevice instance
    /// without needing to create a full route.
    /// </summary>
    /// <param name="deviceInfo">The device information for the MIDI output device.</param>
    /// <returns>The corresponding <see cref="MidiOutputNode"/>, which contains the active device instance.</returns>
    public MidiOutputNode GetOrCreateOutputNode(MidiDeviceInfo deviceInfo)
    {
        lock (_lock)
        {
            if (_outputNodes.TryGetValue(deviceInfo, out var existingNode))
                return existingNode;

            var device = _engine.CreateMidiOutputDevice(deviceInfo);
            var node = new MidiOutputNode(device);
            
            _activeOutputDevices.Add(device);
            _outputNodes[deviceInfo] = node;

            return node;
        }
    }
    
    /// <summary>
    /// Central dispatcher for all incoming MIDI channel messages from physical devices.
    /// </summary>
    private void OnDeviceMessageReceived(MidiMessage message, MidiDeviceInfo sourceDeviceInfo)
    {
        // Access snapshots directly without locking
        var mpeParserSnapshot = _mpeParsersSnapshot;
        var inputNodeSnapshot = _inputNodesSnapshot;
        var routeSnapshot = _routesSnapshot;
        
        mpeParserSnapshot.TryGetValue(sourceDeviceInfo, out var mpeParser);
        inputNodeSnapshot.TryGetValue(sourceDeviceInfo, out var sourceNode);

        // Perform message processing lock-free using snapshots
        if (mpeParser != null)
        {
            var mpeEvent = mpeParser.ProcessMessage(message);
            if (mpeEvent == null) return;
            foreach (var route in routeSnapshot)
            {
                if (route.Source is not MidiInputNode inputNode ||
                    !inputNode.Device.Info.Equals(sourceDeviceInfo)) continue;
                
                if (route.Destination is MidiTargetNode { Target: Synthesizer synth }) synth.ProcessMpeEvent(mpeEvent);
            }
        }
        else // Standard MIDI processing
        {
            sourceNode?.TriggerMessageOutput(message);
        }
    }

    /// <summary>
    /// Central dispatcher for all incoming SysEx messages from physical devices.
    /// </summary>
    private void OnDeviceSysExReceived(byte[] data, MidiDeviceInfo sourceDeviceInfo)
    {
        // Access input nodes snapshot
        var inputNodeSnapshot = _inputNodesSnapshot;
        if (inputNodeSnapshot.TryGetValue(sourceDeviceInfo, out var sourceNode))
        {
            sourceNode.TriggerSysExOutput(data);
        }
    }

    /// <inheritdoc />
    public void Dispose()
    {
        lock (_lock)
        {
            foreach (var route in _routesStaging.ToList())
            {
                RemoveRoute(route); // This safely stops and unsubscribes the route.
            }
            _routesStaging.Clear();
            _routesSnapshot = [];

            foreach (var device in _activeInputDevices)
            {
                device.OnMessageReceived -= OnDeviceMessageReceived;
                device.OnSysExReceived -= OnDeviceSysExReceived;
                device.Dispose();
            }
            _activeInputDevices.Clear();
            
            _inputNodesStaging.Clear();
            _inputNodesSnapshot = new Dictionary<MidiDeviceInfo, MidiInputNode>();
            
            foreach (var device in _activeOutputDevices)
            {
                device.Dispose();
            }
            _activeOutputDevices.Clear();
            _outputNodes.Clear();
            
            _mpeZones.Clear();
            _mpeParsersStaging.Clear();
            _mpeParsersSnapshot = new Dictionary<MidiDeviceInfo, MpeParser>();
        }
    }
    
    /// <summary>
    /// A stateful parser for interpreting an MPE MIDI stream.
    /// </summary>
    private class MpeParser(MpeZone zone)
    {
        private readonly Dictionary<int, int> _channelToNoteMap = new(); // Maps a member channel to the note it's playing
        private readonly Queue<int> _freeChannels = new(Enumerable.Range(zone.MemberChannelsStart, zone.MemberChannelCount));
        
        // MPE State
        private int _perNotePitchBendRange = 48; // MPE spec default
        private int _rpnMsb = -1;
        private int _rpnLsb = -1;
        private int _dataMsb = -1;

        public object? ProcessMessage(MidiMessage message)
        {
            // Handle master channel messages for global controls
            if (message.Channel == zone.MasterChannel)
            {
                switch (message.Command)
                {
                    case MidiCommand.PitchBend:
                        return new GlobalPitchBendEvent(message.PitchBendValue);

                    case MidiCommand.ControlChange:
                        // Intercept RPN messages for per-note pitch bend range
                        switch (message.ControllerNumber)
                        {
                            case 101: _rpnMsb = message.ControllerValue; return null; // Consume
                            case 100: _rpnLsb = message.ControllerValue; return null; // Consume
                            case 6:   _dataMsb = message.ControllerValue; return null; // Consume
                            case 38: // Data Entry LSB
                                if (_rpnMsb == 0 && _rpnLsb == 0 && _dataMsb != -1)
                                {
                                    // This is the Per-Note Pitch Bend Range RPN
                                    _perNotePitchBendRange = _dataMsb; // LSB is for fine-tuning, typically not used for range
                                    _dataMsb = -1; // Reset data entry state
                                }
                                return null; // Consume
                        }
                        break;
                }
                
                // Pass other master channel messages (like Program Change, global CCs) through
                return message;
            }

            // Check if the message is on a member channel
            if (message.Channel < zone.MemberChannelsStart ||
                message.Channel >= zone.MemberChannelsStart + zone.MemberChannelCount)
                return null; // Drop irrelevant messages
            
            switch (message.Command)
            {
                case MidiCommand.NoteOn when message.Velocity > 0:
                    if (_freeChannels.Count <= 0) return null; // No free channels, drop note
                    var assignedChannel = _freeChannels.Dequeue();
                    _channelToNoteMap[assignedChannel] = message.NoteNumber;
                    // Forward the Note On message on the newly assigned member channel
                    return message with { StatusByte = (byte)(0x90 | (assignedChannel - 1)) };

                case MidiCommand.NoteOff:
                case MidiCommand.NoteOn when message.Velocity == 0:
                    // Find which channel was playing this note, free it, and forward the Note Off
                    var channelToFree = _channelToNoteMap.FirstOrDefault(kvp => kvp.Value == message.NoteNumber).Key;
                    if (channelToFree == 0) return null;
                    _channelToNoteMap.Remove(channelToFree);
                    _freeChannels.Enqueue(channelToFree);
                    return message with { StatusByte = (byte)(0x80 | (channelToFree - 1)) };

                case MidiCommand.PitchBend:
                    if (_channelToNoteMap.TryGetValue(message.Channel, out var note))
                    {
                        var bend = (message.PitchBendValue - 8192) / 8192.0f * _perNotePitchBendRange;
                        return new PerNotePitchBendEvent(message.Channel, note, bend);
                    }
                    break;

                case MidiCommand.ChannelPressure:
                    if (_channelToNoteMap.TryGetValue(message.Channel, out note))
                    {
                        return new PerNotePressureEvent(message.Channel, note, message.Data1 / 127.0f);
                    }
                    break;

                case MidiCommand.ControlChange when message.ControllerNumber == 74: // Timbre
                    if (_channelToNoteMap.TryGetValue(message.Channel, out note))
                    {
                        return new PerNoteTimbreEvent(message.Channel, note, message.ControllerValue / 127.0f);
                    }
                    break;
            }
            return null; // Drop irrelevant messages
        }
    }
}